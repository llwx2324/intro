<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘文鑫-个人博客</title>
  
  
  <link href="https://llwx2324.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://llwx2324.github.io/blog/"/>
  <updated>2025-11-13T02:27:08.606Z</updated>
  <id>https://llwx2324.github.io/blog/</id>
  
  <author>
    <name>刘文鑫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找</title>
    <link href="https://llwx2324.github.io/blog/2025/11/13/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://llwx2324.github.io/blog/2025/11/13/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2025-11-13T02:00:00.000Z</published>
    <updated>2025-11-13T02:27:08.606Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="1、lc74-搜索二维矩阵"><a href="#1、lc74-搜索二维矩阵" class="headerlink" title="1、lc74-搜索二维矩阵"></a>1、lc74-搜索二维矩阵</h2><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><ul><li>二维数组下标与一维数组下标的映射</li><li>取mid坐标防止溢出的写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m * n - <span class="number">1</span>; <span class="comment">// 将二维矩阵看作长度为 m*n 的一维数组</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;<span class="comment">// 和 (l + r) / 2 结果相同，但养成这样的习惯可以防止溢出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mVal</span> <span class="operator">=</span> matrix[mid / n][mid % n]; <span class="comment">// 转换回二维坐标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mVal == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(mVal &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mVal &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、lc34-在排序数组中查找元素的第一个和最后一个位置"><a href="#2、lc34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="2、lc34-在排序数组中查找元素的第一个和最后一个位置"></a>2、lc34-在排序数组中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> -<span class="number">1</span>, max = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找左边界</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt;= target) r = m - <span class="number">1</span>;<span class="comment">//往左逼，相等时也要往左逼</span></span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m] == target) min = m;<span class="comment">//每次相等都会先记录一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找右边界</span></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m] == target) max = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;min, max&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、lc33-搜索旋转排序数组"><a href="#3、lc33-搜索旋转排序数组" class="headerlink" title="3、lc33-搜索旋转排序数组"></a>3、lc33-搜索旋转排序数组</h2><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><ul><li>将数组从中间分成左右两部分，一定有一部分数组是有序的</li><li>根据有序的那部分确定该如何改变上下界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 命中直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次都要分，分出哪部分是有序的，有序的才可以用二分思想缩小边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123; <span class="comment">// 要有等于号</span></span><br><span class="line">                <span class="comment">//判断了哪部分是有序数组才能用二分，在有序数组中才能用二分</span></span><br><span class="line">                <span class="comment">//然后确定target是否在有序区间这里</span></span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123; <span class="comment">// target在有序区间这</span></span><br><span class="line">                    r = mid - <span class="number">1</span>; <span class="comment">// 将范围缩小到这个区间</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// target不在有序区间这</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;  <span class="comment">//将范围缩小到另一个区间，下一次while循环又会将这个区间分成有序和无序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、lc153-寻找旋转排序数组中的最小值"><a href="#4、lc153-寻找旋转排序数组中的最小值" class="headerlink" title="4、lc153-寻找旋转排序数组中的最小值"></a>4、lc153-寻找旋转排序数组中的最小值</h2><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不是找目标值，无需一直找下去直到 l == r</span></span><br><span class="line">        <span class="comment">// 当 l == r 时就是最小值的位置了，就不能再进去循环改变 l 和 r 的值了</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是找目标值，模板稍微有些不同</span></span><br><span class="line">            <span class="comment">// 通过 nums[m] 和 nums[r] 的大小关系来判断最小值在哪边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; nums[r])&#123;</span><br><span class="line">                <span class="comment">//最小值在左边的区间（包含 m）</span></span><br><span class="line">                r = m; <span class="comment">// 缩小区间</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 否则在右边的区间</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、lc4-寻找两个正序数组的中位数"><a href="#5、lc4-寻找两个正序数组的中位数" class="headerlink" title="5、lc4-寻找两个正序数组的中位数"></a>5、lc4-寻找两个正序数组的中位数</h2><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><p><img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/image-20251111092205333.png" alt="image-20251111092205333"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保 nums1 是较短的数组</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">// 二分的「边界」不是数组下标，而是“分割线的位置”，所以要取到 m</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = m;</span><br><span class="line">        <span class="comment">// LMax 表示左半部分的最大值</span></span><br><span class="line">        <span class="comment">// RMin 表示右半部分的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">LMax</span> <span class="operator">=</span> <span class="number">0</span>, RMin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在较短的数组 nums1 上进行二分查找</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// i 为 nums1 的分割点，左边有 i 个元素</span></span><br><span class="line">            <span class="comment">// 在较短的数组上确定分割线的位置，保证分割线两边两个数组都有元素，防止下标越界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>; </span><br><span class="line">            <span class="comment">// j 根据总长度确定，使左半部分元素个数为 (m + n + 1) / 2</span></span><br><span class="line">            <span class="comment">// 确保时刻都满足找中位数的数量关系：整体左半部分的元素个数等于右半部分的元素个数（或多一个）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取分割线两侧关键值，注意边界情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nums1LMax</span> <span class="operator">=</span> (i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>]); <span class="comment">// nums1 左边最大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nums1RMin</span> <span class="operator">=</span> (i == m ? Integer.MAX_VALUE : nums1[i]);     <span class="comment">// nums1 右边最小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nums2LMax</span> <span class="operator">=</span> (j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>]); <span class="comment">// nums2 左边最大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nums2RMin</span> <span class="operator">=</span> (j == n ? Integer.MAX_VALUE : nums2[j]);     <span class="comment">// nums2 右边最小值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 满足部分条件，要继续往右逼找到最大满足条件的 i</span></span><br><span class="line">            <span class="keyword">if</span> (nums1LMax &lt;= nums2RMin) &#123;</span><br><span class="line">                <span class="comment">// 更新当前的左半部分最大值和右半部分最小值</span></span><br><span class="line">                LMax = Math.max(nums1LMax, nums2LMax);</span><br><span class="line">                RMin = Math.min(nums1RMin, nums2RMin);</span><br><span class="line">                <span class="comment">// i 右移，尝试让 nums1 多分一些元素给左半部分</span></span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若 nums1LMax &gt; nums2RMin，说明 i 太大，应向左收缩</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据总长度奇偶性返回中位数</span></span><br><span class="line">        <span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (LMax + RMin) / <span class="number">2.0</span> : LMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二分查找的一些经典题型。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven 核心知识体系</title>
    <link href="https://llwx2324.github.io/blog/2025/11/08/Maven%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    <id>https://llwx2324.github.io/blog/2025/11/08/Maven%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</id>
    <published>2025-11-08T08:00:00.000Z</published>
    <updated>2025-11-08T08:42:22.284Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="1️⃣-Maven-基本概念"><a href="#1️⃣-Maven-基本概念" class="headerlink" title="1️⃣ Maven 基本概念"></a>1️⃣ Maven 基本概念</h2><ul><li><strong>Maven</strong> 是一个项目管理和构建工具，用于：<ol><li><strong>依赖管理</strong>（自动下载 jar 包及传递依赖）</li><li><strong>项目构建</strong>（编译、打包、测试、部署）</li><li><strong>生命周期管理</strong>（规范化构建流程）</li></ol></li><li><strong>核心文件</strong>：<code>pom.xml</code><ul><li>描述项目的 <strong>坐标</strong>（groupId、artifactId、version）</li><li>声明 <strong>依赖</strong>、<strong>插件</strong>、<strong>模块</strong> 等</li></ul></li></ul><hr><h2 id="2️⃣-Maven-坐标"><a href="#2️⃣-Maven-坐标" class="headerlink" title="2️⃣ Maven 坐标"></a>2️⃣ Maven 坐标</h2><table><thead><tr><th>坐标</th><th>说明</th></tr></thead><tbody><tr><td>groupId</td><td>组织或公司标识，如 <code>com.yehai</code></td></tr><tr><td>artifactId</td><td>项目名或模块名，如 <code>common</code></td></tr><tr><td>version</td><td>项目版本，如 <code>1.0.0</code></td></tr><tr><td>packaging</td><td>打包类型：<code>jar</code>、<code>war</code>、<code>pom</code> 等</td></tr></tbody></table><ul><li>父子模块关系：<ul><li>父 POM 用 <code>&lt;packaging&gt;pom&lt;/packaging&gt;</code> 管理多个子模块</li><li>子模块通过 <code>&lt;parent&gt;</code> 引用父 POM</li></ul></li></ul><hr><h2 id="3️⃣-依赖管理"><a href="#3️⃣-依赖管理" class="headerlink" title="3️⃣ 依赖管理"></a>3️⃣ 依赖管理</h2><h3 id="依赖声明"><a href="#依赖声明" class="headerlink" title="依赖声明"></a>依赖声明</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用域 (scope)</strong>：</li></ul><table><thead><tr><th>scope</th><th>编译时</th><th>运行时</th><th>打包</th><th>典型用途</th></tr></thead><tbody><tr><td>compile</td><td>✅</td><td>✅</td><td>✅</td><td>默认，核心依赖</td></tr><tr><td>provided</td><td>✅</td><td>❌</td><td>❌</td><td>容器&#x2F;环境提供，如 servlet-api</td></tr><tr><td>runtime</td><td>❌</td><td>✅</td><td>✅</td><td>仅运行时依赖，如 JDBC driver</td></tr><tr><td>test</td><td>❌</td><td>❌</td><td>❌</td><td>测试依赖，如 JUnit</td></tr><tr><td>system</td><td>✅</td><td>✅</td><td>❌</td><td>本地 jar，不推荐</td></tr></tbody></table><h3 id="传递依赖"><a href="#传递依赖" class="headerlink" title="传递依赖"></a>传递依赖</h3><ul><li>Maven 自动解析依赖的依赖（transitive dependency）</li><li>可以通过 <code>&lt;dependencyManagement&gt;</code> 或 <code>&lt;exclusions&gt;</code> 控制版本冲突或排除依赖</li></ul><hr><h2 id="4️⃣-Maven-生命周期"><a href="#4️⃣-Maven-生命周期" class="headerlink" title="4️⃣ Maven 生命周期"></a>4️⃣ Maven 生命周期</h2><table><thead><tr><th>生命周期</th><th>阶段</th><th>作用</th></tr></thead><tbody><tr><td><strong>clean</strong></td><td>clean</td><td>清理上次构建生成的文件（通常是 <code>target</code>）</td></tr><tr><td><strong>default</strong></td><td>validate</td><td>验证项目结构和必要信息是否完整</td></tr><tr><td></td><td>compile</td><td>编译主源码</td></tr><tr><td></td><td>test</td><td>运行单元测试</td></tr><tr><td></td><td>package</td><td>打包成 jar&#x2F;war</td></tr><tr><td></td><td>verify</td><td>验证打包是否正确</td></tr><tr><td></td><td>install</td><td>安装到本地Maven仓库 (<code>~/.m2</code>)</td></tr><tr><td></td><td>deploy</td><td>部署到远程Maven仓库</td></tr><tr><td><strong>site</strong></td><td>site</td><td>生成项目文档</td></tr></tbody></table><ul><li><p><strong>顺序执行</strong>：运行某个阶段时，会依次执行<strong>同周期</strong>的前面的阶段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br><span class="line"><span class="comment"># 等效执行: （没有clean）validate → compile → test → package</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5️⃣-Maven-插件"><a href="#5️⃣-Maven-插件" class="headerlink" title="5️⃣ Maven 插件"></a>5️⃣ Maven 插件</h2><ul><li>Maven 的功能主要由插件提供</li><li>常用插件：</li></ul><table><thead><tr><th>插件</th><th>功能</th></tr></thead><tbody><tr><td>maven-compiler-plugin</td><td>编译 java 代码</td></tr><tr><td>maven-surefire-plugin</td><td>单元测试执行</td></tr><tr><td>maven-jar-plugin</td><td>打 jar 包</td></tr><tr><td>maven-war-plugin</td><td>打 war 包</td></tr><tr><td>maven-dependency-plugin</td><td>分析&#x2F;复制依赖</td></tr><tr><td>spring-boot-maven-plugin</td><td>Spring Boot 打包和运行</td></tr></tbody></table><hr><h2 id="6️⃣-多模块项目"><a href="#6️⃣-多模块项目" class="headerlink" title="6️⃣ 多模块项目"></a>6️⃣ 多模块项目</h2><ul><li>父模块 (packaging&#x3D;pom)</li><li>子模块通过 <code>&lt;modules&gt;</code> 声明</li><li>子模块可以继承父模块的依赖管理、插件管理、属性</li><li>Maven 会按顺序构建父模块 → 子模块</li></ul><hr><h2 id="7️⃣-依赖冲突处理"><a href="#7️⃣-依赖冲突处理" class="headerlink" title="7️⃣ 依赖冲突处理"></a>7️⃣ 依赖冲突处理</h2><ul><li><p>当多个版本的依赖出现时，Maven 使用 <strong>最近优先原则</strong>：</p><ul><li>以 <strong>依赖树中最短路径</strong>的版本为准</li></ul></li><li><p>可以通过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure><p>查看依赖树和冲突</p></li></ul>]]></content>
    
    
    <summary type="html">Maven 核心知识体系。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>component与配置类注册bean的区别、maven作用域（结合实际场景）</title>
    <link href="https://llwx2324.github.io/blog/2025/11/08/component%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81maven%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88%E7%BB%93%E5%90%88%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%EF%BC%89/"/>
    <id>https://llwx2324.github.io/blog/2025/11/08/component%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81maven%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88%E7%BB%93%E5%90%88%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%EF%BC%89/</id>
    <published>2025-11-08T08:00:00.000Z</published>
    <updated>2025-11-08T09:10:54.496Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><ol><li><code>hm-common</code>模块里编写了<code>RabbitMQHelper</code>工具类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFutureCallback;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">// 防止篇幅太长，方法就简写示意一下了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object message)</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange, String routingKey, Object message, <span class="type">int</span> delay)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgWithConfirm</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries)</span> &#123;</span><br><span class="line">        sendMsgWithConfirmInternal(exchange, routingKey, msg, maxRetries, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgWithConfirmInternal</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries, <span class="type">int</span> currentRetry)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>hm-common</code>模块里有amqp和rabbit相关依赖但是scope是provided</p></li><li><p>其他继承了<code>hm-common</code>模块的模块调用<code>RabbitMQHelper</code>工具类来发送消息，报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: org/springframework/amqp/core/Message</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.springframework.amqp.core.Message</span><br></pre></td></tr></table></figure></li><li><p>将<code>RabbitMQHelper</code>工具类做如下<code>改动</code>之后就不报错正常运行了</p><ul><li><p>去掉<code>@Component</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFutureCallback;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">// 防止篇幅太长，方法就简写示意一下了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object message)</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange, String routingKey, Object message, <span class="type">int</span> delay)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgWithConfirm</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries)</span> &#123;</span><br><span class="line">        sendMsgWithConfirmInternal(exchange, routingKey, msg, maxRetries, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgWithConfirmInternal</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries, <span class="type">int</span> currentRetry)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置类中注册为<code>Bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RabbitMQHelper <span class="title function_">rabbitMQHelper</span><span class="params">(RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RabbitMQHelper</span>(rabbitTemplate);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><ol><li><p><code>@Component</code></p><ul><li><p>被标注了 <code>@Component</code>的类，Spring 在<strong>启动时就会扫描并创建 Bean</strong>，并且，Spring 会<strong>加载类及其构造器、字段类型</strong>。而 <code>RabbitMQHelper</code> 构造器有 <code>RabbitTemplate</code> 参数，而 <code>RabbitTemplate</code> 依赖<code>org.springframework.amqp.core.Message</code>等类。<code>common</code> 模块里 <code>spring-rabbit</code> 依赖的 scope 被标记为 <code>provided</code>，<strong>编译可以用，但运行时 JVM 找不到</strong> <code>Message</code> 类。</p><p>所以启动时报 <code>NoClassDefFoundError</code>。</p></li></ul></li><li><p><code>@Bean</code>：</p><ul><li>使用<strong>配置类注册 Bean</strong> 时，Spring <strong>延迟创建 Bean</strong>，直到<strong>调用</strong>方法时才真正需要 <code>RabbitTemplate</code>。这时才会用到 <code>spring-rabbit</code> 依赖。而调用方法的模块是有<code>spring-rabbit</code> 依赖的</li></ul></li></ol><table><thead><tr><th>方式</th><th>特点</th><th>风险</th></tr></thead><tbody><tr><td><code>@Component + @RequiredArgsConstructor</code></td><td>Spring 扫描组件，自动注入</td><td>扫描时必须能加载类依赖，否则 NoClassDefFoundError</td></tr><tr><td>配置类 <code>@Bean</code> 方法</td><td>手动创建 Bean，延迟注入</td><td>扫描时不解析类依赖，风险低</td></tr></tbody></table><ol start="3"><li><code>provided</code>: （相关详解：<a href="https://llwx2324.github.io/blog/2025/11/08/Maven%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">Maven 核心知识体系</a>）</li></ol><ul><li>作用域：编译（有） + 运行（无） + 打包（无）</li></ul><p>⚠️ 如果 common 模块不直接依赖 AMQP，只在别的模块使用 <code>RabbitMQHelper</code>，那用provided + 配置类注册是最好的方式。</p>]]></content>
    
    
    <summary type="html">component与配置类注册bean的区别、maven provided 作用域（结合实际场景）。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>回溯法</title>
    <link href="https://llwx2324.github.io/blog/2025/11/06/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>https://llwx2324.github.io/blog/2025/11/06/%E5%9B%9E%E6%BA%AF%E6%B3%95/</id>
    <published>2025-11-06T02:00:00.000Z</published>
    <updated>2025-11-13T02:26:47.366Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h2><p><strong>应用场景</strong></p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p><strong>如何理解回溯法</strong></p><ul><li><p>回溯的本质是穷举，穷举所有可能，选出我们想要的答案</p></li><li><p>回溯法解决的问题都可抽象为树形结构</p></li><li><p>回溯法解决的问题都是在集合中递归查找子集</p></li><li><p>集合的大小构成了树的宽度，递归的深度构成树的深度</p></li><li><p><img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/20210130173631174.png" alt="回溯算法理论基础"></p></li><li><p>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</p></li><li><p>模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (找到一个结果的终止条件) &#123;</span><br><span class="line">        存放单次结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点/处理单次结果;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2、lc77-组合"><a href="#2、lc77-组合" class="headerlink" title="2、lc77-组合"></a>2、lc77-组合</h2><p>原题链接：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p><ul><li>回溯法用递归来解决嵌套for循环层数的问题</li><li>每一次的递归中一个for循环，那么递归就可以用于解决多层嵌套循环的问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtrack(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> si)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> si; i &lt;= n; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtrack(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剪枝优化版</strong></p><ul><li>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        combineHelper(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">combineHelper</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            combineHelper(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、lc46-全排列"><a href="#3、lc46-全排列" class="headerlink" title="3、lc46-全排列"></a>3、lc46-全排列</h2><p>组合无序，排列有序</p><p><a href="https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/permutations/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><ul><li>因为排列问题每次都要从头开始搜索（因为排列是有序的，这样才能得到所有排列的可能），因此可能会遍历到已使用过的元素（一个排列里一个元素只能使用一次）。而 <strong>used数组</strong> 就是拿来记录此时path里都有哪些元素使用了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            path.remove(Integer.valueOf(nums[i]));</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、lc78-子集"><a href="#4、lc78-子集" class="headerlink" title="4、lc78-子集"></a>4、lc78-子集</h2><p><a href="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><ul><li>组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点</li><li>无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        subsetsHelper(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subsetsHelper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));<span class="comment">//「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length)&#123; <span class="comment">//终止条件可不加</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            subsetsHelper(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、lc17-电话号码的字母组合"><a href="#5、lc17-电话号码的字母组合" class="headerlink" title="5、lc17-电话号码的字母组合"></a>5、lc17-电话号码的字母组合</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><ul><li>本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，因此每次递归到下一层遍历都要从头开始（从 0 开始）遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        Map&lt;Character, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        backtrack(map, digits, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sI表示遍历到哪个数字了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Map&lt;Character, String&gt; map, String digits, <span class="type">int</span> sI)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.length() == digits.length())&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> map.get(digits.charAt(sI));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            path.append(s.charAt(i));</span><br><span class="line">            backtrack(map, digits, sI + <span class="number">1</span>);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、lc39-组合总和"><a href="#6、lc39-组合总和" class="headerlink" title="6、lc39-组合总和"></a>6、lc39-组合总和</h2><p><a href="https://leetcode.cn/problems/combination-sum/solutions/406516/zu-he-zong-he-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/combination-sum/solutions/406516/zu-he-zong-he-by-leetcode-solution/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><ul><li>组合问题：一个集合来求组合的话，就需要startIndex；多个集合取组合，就不用startIndex</li><li>startIndex组合是无序的，虽然本题说明可以重复选取，但最多下一层只能从当前元素的位置开始（往前），绝对是不能从下标 0 开始的（往后重新开始），所以要用到startIndex</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> sI)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sI; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            backtrack(candidates, target, sum, i); <span class="comment">//元素可重复选取，因此传入当前位置 i</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、lc22-括号生成"><a href="#7、lc22-括号生成" class="headerlink" title="7、lc22-括号生成"></a>7、lc22-括号生成</h2><p><a href="https://leetcode.cn/problems/generate-parentheses/solutions/192912/gua-hao-sheng-cheng-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/generate-parentheses/solutions/192912/gua-hao-sheng-cheng-by-leetcode-solution/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><p><img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/image-20251103095323435.png" alt="image-20251103095323435"></p><ul><li>组合 &#x2F; 子集 &#x2F; 排列：同一层可以选择多个不同元素；括号生成：每一层只有两种固定决策：要么 <code>&#39;(&#39;</code> 要么 <code>&#39;)&#39;</code>，不需要for</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtrack(n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.length() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以放左括号</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            path.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            backtrack(n, left + <span class="number">1</span>, right);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以放右括号</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">            path.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backtrack(n, left, right + <span class="number">1</span>);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8、lc79-单词搜索"><a href="#8、lc79-单词搜索" class="headerlink" title="8、lc79-单词搜索"></a>8、lc79-单词搜索</h2><p><a href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 遍历所有起点，只要有一个起点能匹配成功就返回 true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索 + 回溯</span></span><br><span class="line">    <span class="comment">// k 表示当前匹配到 word 的第 k 个字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 越界判断 或 当前字符不匹配，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length </span><br><span class="line">            || board[i][j] != word.charAt(k)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 若已匹配到最后一个字符，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 临时标记当前格子为已访问，防止重复使用</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j]; <span class="comment">//存下来以便回溯</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;  <span class="comment">// &#x27;#&#x27; 表示该格子已用过</span></span><br><span class="line">        <span class="comment">// 四个方向继续搜索</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                        dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                        dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) ||</span><br><span class="line">                        dfs(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯：恢复当前格子的原值</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9、lc131-分割回文串"><a href="#9、lc131-分割回文串" class="headerlink" title="9、lc131-分割回文串"></a>9、lc131-分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯 + 普通判断回文串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtrack(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> sI)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sI &gt;= s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">//每层递归都单独有一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sI; i &lt; s.length(); i++)&#123;</span><br><span class="line">            sb.append(s.charAt(i)); <span class="comment">//每层递归都有自己独立的sb，因此不用撤销，撤销没影响主要是，你撤销撤销的是当层的sb，但是你回到上一层时又是上一层它自己独立的新的sb，因此只有path才有撤销的必要</span></span><br><span class="line">            <span class="keyword">if</span>(isPalin(sb)&#123;</span><br><span class="line">                path.add(sb.toString());</span><br><span class="line">                backtrack(s, i + <span class="number">1</span>);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalin</span><span class="params">(StringBuilder sb)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = sb.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(l) != sb.charAt(r)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯 + 动规判断回文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//链表增删效率更高</span></span><br><span class="line">    <span class="type">boolean</span>[][] dp; <span class="comment">// 下标从 i 到 j 的子串是否是回文</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>]; <span class="comment">// 多开一行一列保险</span></span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        isPalindrome(str); <span class="comment">// 先预处理，判断好所有子串是否是回文</span></span><br><span class="line">        backtrack(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> sI)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sI &gt;= s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sI; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[sI][i])&#123;</span><br><span class="line">                path.addLast(s.substring(sI, i + <span class="number">1</span>));</span><br><span class="line">                backtrack(s, i + <span class="number">1</span>);</span><br><span class="line">                path.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//单个字符一定是回文</span></span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123; <span class="comment">// i从 1 往右走</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123; <span class="comment">// j 从 i 的左边一个位置一直往左走</span></span><br><span class="line">                <span class="keyword">if</span>(str[i] == str[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - j == <span class="number">1</span>)&#123; <span class="comment">// 相等且紧邻时</span></span><br><span class="line">                        dp[j][i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j + <span class="number">1</span>][i - <span class="number">1</span>])&#123; <span class="comment">// 相等且内子串为回文时</span></span><br><span class="line">                        dp[j][i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、lc51-N皇后"><a href="#10、lc51-N皇后" class="headerlink" title="10、lc51-N皇后"></a>10、lc51-N皇后</h2><p><a href="https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><ul><li>棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : board)&#123; <span class="comment">//初始化棋盘</span></span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= n)&#123;</span><br><span class="line">            res.add(array2List(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(board, row, i))&#123; <span class="comment">//先判断这个位置能不能放 Q</span></span><br><span class="line">                board[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                backtrack(n, row + <span class="number">1</span>);</span><br><span class="line">                board[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">array2List</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : board)&#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意别搞混行列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123; <span class="comment">//只需往“上”检查</span></span><br><span class="line">        <span class="comment">//检查列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查上半部分主对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查上半部分副对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">回溯法的一些经典题型。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring AMQP 下 Publisher Confirms 和 Publisher Returns 的对比</title>
    <link href="https://llwx2324.github.io/blog/2025/11/05/Spring%20AMQP%20%E4%B8%8B%20Publisher%20Confirms%20%E5%92%8C%20Publisher%20Returns%20%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>https://llwx2324.github.io/blog/2025/11/05/Spring%20AMQP%20%E4%B8%8B%20Publisher%20Confirms%20%E5%92%8C%20Publisher%20Returns%20%E7%9A%84%E5%AF%B9%E6%AF%94/</id>
    <published>2025-11-05T09:00:00.000Z</published>
    <updated>2025-11-05T09:19:33.273Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>ReturnCallback</code> 和 <code>ConfirmCallback</code> 是在使用 Spring AMQP（Spring Data RabbitMQ）框架时，对标准 RabbitMQ 客户端的 <code>ReturnListener</code> 和 <code>ConfirmListener</code> 机制进行的高级封装。</p><p>它们是 Spring Boot&#x2F;Spring Cloud 应用中实现消息可靠性的<strong>核心接口</strong>。</p><hr><h3 id="1-🔄-ConfirmCallback-对应-Publisher-Confirms"><a href="#1-🔄-ConfirmCallback-对应-Publisher-Confirms" class="headerlink" title="1. 🔄 ConfirmCallback (对应 Publisher Confirms)"></a>1. 🔄 ConfirmCallback (对应 Publisher Confirms)</h3><p><code>ConfirmCallback</code> 接口用于处理 <strong>生产者确认（Publisher Confirms）</strong> 的结果。它告诉生产者消息是否已被 RabbitMQ Broker 成功接收。</p><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><ul><li><strong>关注阶段：</strong> 生产者 $\rightarrow$ Broker。</li><li><strong>如何使用：</strong> 将该回调实现类加到 <code>correlationData</code> 的<code>future</code>中（每次发消息都要指定，因此一般是写在业务代码中）。</li><li><strong>核心逻辑：</strong><ul><li>如果 <code>ack</code> 为 <code>true</code>：表示消息安全到达 Broker，可以从重发队列或内存中移除这条消息。</li><li>如果 <code>ack</code> 为 <code>false</code>：表示消息未能被 Broker 接收（通常是网络问题或 Broker 内部错误），需要根据 <code>correlationData</code> 尝试<strong>重发</strong>或记录失败日志。</li></ul></li></ul><hr><h3 id="2-↩️-ReturnCallback-对应-Publisher-Returns"><a href="#2-↩️-ReturnCallback-对应-Publisher-Returns" class="headerlink" title="2. ↩️ ReturnCallback (对应 Publisher Returns)"></a>2. ↩️ ReturnCallback (对应 Publisher Returns)</h3><p><code>ReturnCallback</code> 接口用于处理 <strong>生产者返回（Publisher Returns）</strong> 的事件。它告诉生产者消息虽然被 Broker 接收了，但 Exchange 无法将其路由到任何队列。</p><h4 id="关注点-1"><a href="#关注点-1" class="headerlink" title="关注点"></a>关注点</h4><ul><li><strong>关注阶段：</strong> Exchange $\rightarrow$ Queue。</li><li><strong>如何使用：</strong> 将该回调实现类注入到 Spring 的 <code>RabbitTemplate</code> 中（只能配置一个，配置类中配置）</li><li><strong>核心逻辑：</strong><ul><li>该回调方法被调用，意味着<strong>消息已丢失</strong>（无法被消费者获取）。</li><li>生产者应检查 <code>replyText</code> 和 <code>routingKey</code>，通常需要记录详细日志，然后将 <code>message</code> <strong>重新发送</strong>到备用 Exchange 或人工处理队列，以防止数据丢失。</li></ul></li></ul><hr><h3 id="📊-总结对比-Spring-AMQP-视角"><a href="#📊-总结对比-Spring-AMQP-视角" class="headerlink" title="📊 总结对比 (Spring AMQP 视角)"></a>📊 总结对比 (Spring AMQP 视角)</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>ConfirmCallback</strong></th><th><strong>ReturnCallback</strong></th></tr></thead><tbody><tr><td><strong>底层对应</strong></td><td>Publisher Confirms (Ack&#x2F;Nack)</td><td>Publisher Returns</td></tr><tr><td><strong>何时触发</strong></td><td>消息被 <strong>Broker 接收&#x2F;拒绝</strong> 时</td><td>消息被 <strong>Exchange 接收</strong> 且 <strong>无法路由</strong> 到任何队列时</td></tr><tr><td><strong>关注重点</strong></td><td><strong>接收的安全性</strong></td><td><strong>路由的准确性</strong></td></tr><tr><td><strong>核心参数</strong></td><td><code>ack</code> (布尔值) 和 <code>cause(reason)</code></td><td><code>message</code> 和 <code>replyCode</code>&#x2F;<code>replyText</code></td></tr><tr><td><strong>典型处理</strong></td><td>Ack: 清除记录；Nack: <strong>重发</strong>消息</td><td>记录日志并决定是否 <strong>重新路由</strong></td></tr></tbody></table><p><strong>重要提示：</strong></p><p>在 Spring AMQP 中，这两个回调函数是实现<strong>端到端可靠性</strong>的黄金搭档。它们使业务逻辑能够清晰地处理消息发送过程中的所有异常情况。</p><p><strong>使用步骤</strong>：</p><p>1.<img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/image-20251105162446530.png" alt="image-20251105162446530"></p><p>2.<img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/image-20251105162521843.png" alt="image-20251105162521843"></p><ol start="3"><li></li></ol><p><img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/image-20251105162550437.png" alt="image-20251105162550437"></p><p>！<strong>但是以上机制都一般不会开启</strong></p>]]></content>
    
    
    <summary type="html">Spring AMQP 下 Publisher Confirms 和 Publisher Returns 的对比。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Gemini CLI无法登录的问题</title>
    <link href="https://llwx2324.github.io/blog/2025/11/03/Gemini%20CLI%E6%97%A0%E6%B3%95%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://llwx2324.github.io/blog/2025/11/03/Gemini%20CLI%E6%97%A0%E6%B3%95%E7%99%BB%E5%BD%95%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-11-03T11:35:00.000Z</published>
    <updated>2025-11-03T11:59:48.450Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/image-20251103195828642.png" alt="image-20251103195828642"></p><p>以下是我成功登入的过程：</p><p>初步检查</p><p>我已开启 Clash 的 TUN 模式，并配置了相关环境变量。</p><p><img src="https://ye-hai.oss-cn-shenzhen.aliyuncs.com/typora/image-20251103195843175.png" alt="image-20251103195843175"></p><p>为了验证代理是否生效，我在管理员权限的 PowerShell 中执行 netsh winhttp show proxy，发现输出仍为 直接访问（没有代理服务器），说明系统代理未正确设置。<br>手动配置代理</p><p>于是，我通过命令 netsh winhttp set proxy 127.0.0.1:7890 手动设置了 WinHTTP 代理。<br>再次执行 netsh winhttp show proxy，确认代理已生效：<br>代理服务器: 127.0.0.1:7890<br>绕过列表: (无)<br>结果</p><p>完成代理配置后，重新启动 Gemini，问题解决，服务成功运行。</p>]]></content>
    
    
    <summary type="html">Gemini CLI无法登录的问题。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://llwx2324.github.io/blog/2025/10/30/Docker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
    <id>https://llwx2324.github.io/blog/2025/10/30/Docker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</id>
    <published>2025-10-30T02:00:00.000Z</published>
    <updated>2025-11-03T11:52:57.708Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>适用于 CentOS 7 &#x2F; Ubuntu &#x2F; Mac &#x2F; Windows 等环境<br>Docker 版本：18.x ~ 27.x 通用</p></blockquote><hr><h2 id="🚀-一、镜像管理（Images）"><a href="#🚀-一、镜像管理（Images）" class="headerlink" title="🚀 一、镜像管理（Images）"></a>🚀 一、镜像管理（Images）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker images</code></td><td>查看本地镜像</td></tr><tr><td><code>docker search nginx</code></td><td>在 Docker Hub 搜索镜像</td></tr><tr><td><code>docker pull nginx</code></td><td>拉取镜像</td></tr><tr><td><code>docker pull nginx:1.25</code></td><td>拉取指定版本镜像</td></tr><tr><td><code>docker rmi nginx</code></td><td>删除镜像</td></tr><tr><td><code>docker rmi -f &lt;IMAGE_ID&gt;</code></td><td>强制删除镜像</td></tr><tr><td><code>docker image prune</code></td><td>删除未使用镜像</td></tr><tr><td><code>docker save -o nginx.tar nginx</code></td><td>导出镜像到文件</td></tr><tr><td><code>docker load -i nginx.tar</code></td><td>从文件导入镜像</td></tr><tr><td><code>docker tag nginx myrepo/nginx:latest</code></td><td>给镜像打标签</td></tr></tbody></table><hr><h2 id="🧱-二、容器管理（Containers）"><a href="#🧱-二、容器管理（Containers）" class="headerlink" title="🧱 二、容器管理（Containers）"></a>🧱 二、容器管理（Containers）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker ps</code></td><td>查看正在运行的容器</td></tr><tr><td><code>docker ps -a</code></td><td>查看所有容器（包括停止的）</td></tr><tr><td><code>docker run -d --name web nginx</code></td><td>运行容器（后台模式）</td></tr><tr><td><code>docker run -it --name test ubuntu /bin/bash</code></td><td>启动交互式容器</td></tr><tr><td><code>docker exec -it web /bin/bash</code></td><td>进入正在运行的容器</td></tr><tr><td><code>docker stop web</code></td><td>停止容器</td></tr><tr><td><code>docker start web</code></td><td>启动容器</td></tr><tr><td><code>docker restart web</code></td><td>重启容器</td></tr><tr><td><code>docker rm web</code></td><td>删除容器</td></tr><tr><td><code>docker rm -f $(docker ps -aq)</code></td><td>删除所有容器</td></tr><tr><td><code>docker logs web</code></td><td>查看容器日志</td></tr><tr><td><code>docker logs -f web</code></td><td>实时查看日志</td></tr><tr><td><code>docker inspect web</code></td><td>查看容器详细信息</td></tr><tr><td><code>docker top web</code></td><td>查看容器内运行的进程</td></tr><tr><td><code>docker stats</code></td><td>查看容器资源使用情况（CPU、内存等）</td></tr><tr><td><code>docker rename old new</code></td><td>重命名容器</td></tr></tbody></table><hr><h2 id="🌐-三、网络管理（Networks）"><a href="#🌐-三、网络管理（Networks）" class="headerlink" title="🌐 三、网络管理（Networks）"></a>🌐 三、网络管理（Networks）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker network ls</code></td><td>查看所有网络</td></tr><tr><td><code>docker network inspect bridge</code></td><td>查看网络详情</td></tr><tr><td><code>docker network create mynet</code></td><td>创建自定义网络</td></tr><tr><td><code>docker network rm mynet</code></td><td>删除网络</td></tr><tr><td><code>docker network connect mynet web</code></td><td>将容器连接到网络</td></tr><tr><td><code>docker network disconnect mynet web</code></td><td>将容器从网络断开</td></tr><tr><td><code>docker network prune</code></td><td>删除未使用的网络</td></tr></tbody></table><hr><h2 id="📦-四、数据卷管理（Volumes）"><a href="#📦-四、数据卷管理（Volumes）" class="headerlink" title="📦 四、数据卷管理（Volumes）"></a>📦 四、数据卷管理（Volumes）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker volume ls</code></td><td>查看所有数据卷</td></tr><tr><td><code>docker volume create mydata</code></td><td>创建数据卷</td></tr><tr><td><code>docker volume inspect mydata</code></td><td>查看数据卷详情</td></tr><tr><td><code>docker volume rm mydata</code></td><td>删除数据卷</td></tr><tr><td><code>docker volume prune</code></td><td>删除未使用数据卷</td></tr><tr><td><code>docker run -v mydata:/data nginx</code></td><td>运行容器并挂载数据卷</td></tr><tr><td><code>docker run -v /home/user/www:/usr/share/nginx/html nginx</code></td><td>挂载宿主机目录</td></tr></tbody></table><hr><h2 id="🧰-五、构建与管理镜像（Build）"><a href="#🧰-五、构建与管理镜像（Build）" class="headerlink" title="🧰 五、构建与管理镜像（Build）"></a>🧰 五、构建与管理镜像（Build）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker build -t myapp:1.0 .</code></td><td>根据 Dockerfile 构建镜像</td></tr><tr><td><code>docker commit &lt;CONTAINER_ID&gt; myimage:v1</code></td><td>从容器生成新镜像</td></tr><tr><td><code>docker history myimage:v1</code></td><td>查看镜像构建历史</td></tr><tr><td><code>docker image ls</code></td><td>查看所有镜像</td></tr><tr><td><code>docker image rm myimage:v1</code></td><td>删除镜像</td></tr></tbody></table><hr><h2 id="🖧-六、Docker-Compose（多容器编排）"><a href="#🖧-六、Docker-Compose（多容器编排）" class="headerlink" title="🖧 六、Docker Compose（多容器编排）"></a>🖧 六、Docker Compose（多容器编排）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker-compose up -d</code></td><td>启动所有服务（后台运行）</td></tr><tr><td><code>docker-compose down</code></td><td>停止并删除容器、网络</td></tr><tr><td><code>docker-compose ps</code></td><td>查看 Compose 管理的容器</td></tr><tr><td><code>docker-compose logs -f</code></td><td>查看服务日志</td></tr><tr><td><code>docker-compose restart</code></td><td>重启服务</td></tr><tr><td><code>docker-compose build</code></td><td>重新构建镜像</td></tr></tbody></table><hr><h2 id="🧹-七、系统与资源清理"><a href="#🧹-七、系统与资源清理" class="headerlink" title="🧹 七、系统与资源清理"></a>🧹 七、系统与资源清理</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker system df</code></td><td>查看磁盘占用</td></tr><tr><td><code>docker system prune</code></td><td>清理未使用资源</td></tr><tr><td><code>docker system prune -a</code></td><td>清理所有未使用的镜像、容器、网络等</td></tr><tr><td><code>docker info</code></td><td>查看 Docker 系统信息</td></tr><tr><td><code>docker version</code></td><td>查看 Docker 版本信息</td></tr></tbody></table><hr><h2 id="🔒-八、Docker-服务管理（CentOS-7）"><a href="#🔒-八、Docker-服务管理（CentOS-7）" class="headerlink" title="🔒 八、Docker 服务管理（CentOS 7）"></a>🔒 八、Docker 服务管理（CentOS 7）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>systemctl start docker</code></td><td>启动 Docker 服务</td></tr><tr><td><code>systemctl stop docker</code></td><td>停止 Docker 服务</td></tr><tr><td><code>systemctl restart docker</code></td><td>重启 Docker</td></tr><tr><td><code>systemctl status docker</code></td><td>查看 Docker 状态</td></tr><tr><td><code>systemctl enable docker</code></td><td>设置开机自启</td></tr><tr><td><code>systemctl disable docker</code></td><td>取消开机自启</td></tr></tbody></table><hr><h2 id="🧭-九、调试与其他命令"><a href="#🧭-九、调试与其他命令" class="headerlink" title="🧭 九、调试与其他命令"></a>🧭 九、调试与其他命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker inspect &lt;ID&gt;</code></td><td>查看详细 JSON 信息</td></tr><tr><td><code>docker exec -it &lt;容器&gt; bash</code></td><td>进入容器交互终端</td></tr><tr><td><code>docker cp web:/usr/share/nginx/html ./backup</code></td><td>从容器拷贝文件到宿主机</td></tr><tr><td><code>docker cp ./index.html web:/usr/share/nginx/html/</code></td><td>从宿主机拷贝文件进容器</td></tr><tr><td><code>docker diff web</code></td><td>查看容器文件系统的变动</td></tr><tr><td><code>docker events</code></td><td>监听 Docker 实时事件</td></tr><tr><td><code>docker update --restart=always web</code></td><td>设置容器自动重启策略</td></tr></tbody></table><hr><h2 id="💡-十、快速清理命令合集"><a href="#💡-十、快速清理命令合集" class="headerlink" title="💡 十、快速清理命令合集"></a>💡 十、快速清理命令合集</h2><pre class=" language-language-bash"><code class="language-language-bash"># 删除所有已退出容器docker rm $(docker ps -aq -f status=exited)# 删除所有悬空镜像docker rmi $(docker images -q -f dangling=true)# 删除未使用网络、卷、镜像、容器docker system prune -a -f</code></pre>]]></content>
    
    
    <summary type="html">Docker常用命令清单。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot的自动装配</title>
    <link href="https://llwx2324.github.io/blog/2025/10/26/SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>https://llwx2324.github.io/blog/2025/10/26/SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</id>
    <published>2025-10-26T02:00:00.000Z</published>
    <updated>2025-11-03T11:51:03.500Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="🌱-什么是自动装配"><a href="#🌱-什么是自动装配" class="headerlink" title="🌱 什么是自动装配"></a>🌱 什么是自动装配</h2><p>Spring Boot 的自动装配就是：</p><blockquote><p><strong>根据你引入的依赖，自动帮你把相关的 Bean 配好，不用手动写配置。</strong></p></blockquote><p>例如：<br> 你引入了 <code>spring-boot-starter-web</code>，Spring Boot 就会自动帮你配置：</p><ul><li>内嵌 Tomcat</li><li><code>DispatcherServlet</code></li><li>MVC 相关的 Bean</li></ul><p>你什么都不用写，系统就能跑起来。</p><hr><h2 id="⚙️-核心原理"><a href="#⚙️-核心原理" class="headerlink" title="⚙️ 核心原理"></a>⚙️ 核心原理</h2><ol><li><p>启动类上的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br></pre></td></tr></table></figure><p>它包含：</p><ul><li><code>@ComponentScan</code>（扫描组件）</li><li><code>@EnableAutoConfiguration</code>（开启自动配置）</li></ul></li><li><p><code>@EnableAutoConfiguration</code> 会去加载所有配置类<br> （这些类都写在各个 jar 包里的<br> <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中）</p></li><li><p>Spring Boot 会判断：</p><ul><li>哪些类在类路径里存在</li><li>哪些 Bean 你自己没配</li><li>哪些配置项在 <code>application.yml</code> 里定义了</li></ul><p>然后“有条件”地加载对应的配置。</p></li></ol><hr><h2 id="🎯-举个例子"><a href="#🎯-举个例子" class="headerlink" title="🎯 举个例子"></a>🎯 举个例子</h2><p><code>DataSourceAutoConfiguration</code>（数据库自动配置类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是：</p><ul><li>只有项目里有 <code>DataSource</code> 相关类，</li><li>而且你没自己写 <code>DataSource</code> Bean，</li><li>它才自动帮你创建一个默认的。</li></ul><hr><h2 id="💡-小结"><a href="#💡-小结" class="headerlink" title="💡 小结"></a>💡 小结</h2><table><thead><tr><th>关键点</th><th>含义</th></tr></thead><tbody><tr><td><code>@SpringBootApplication</code></td><td>启动入口</td></tr><tr><td><code>@EnableAutoConfiguration</code></td><td>启动自动配置功能</td></tr><tr><td><code>@ConditionalOnXXX</code></td><td>条件判断是否生效</td></tr><tr><td><code>spring.factories</code> &#x2F; <code>AutoConfiguration.imports</code></td><td>存放所有自动配置类列表</td></tr></tbody></table><hr>]]></content>
    
    
    <summary type="html">SpringBoot的自动装配。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>虚拟机中的 MySQL 3306端口被占用、mysql Docker 容器无法自启</title>
    <link href="https://llwx2324.github.io/blog/2025/10/21/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%20MySQL%203306%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E3%80%81mysql%20Docker%20%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%87%AA%E5%90%AF/"/>
    <id>https://llwx2324.github.io/blog/2025/10/21/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%20MySQL%203306%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E3%80%81mysql%20Docker%20%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%87%AA%E5%90%AF/</id>
    <published>2025-10-21T02:00:00.000Z</published>
    <updated>2025-11-03T11:49:10.209Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h2><ul><li>虚拟机上手动安装的 MySQL (<code>/usr/local/mysql/bin/mysqld</code>) 占用 3306</li><li>kill PID 无效（可以先试试杀死占用3306端口的进程），因为有守护进程 <code>mysqld_safe</code> 不断重启</li><li>系统没有 systemd mysqld 服务</li><li>Docker 容器已存在但未启动，需要端口干净并设置开机自启</li></ul><hr><h2 id="完整解决步骤"><a href="#完整解决步骤" class="headerlink" title="完整解决步骤"></a><strong>完整解决步骤</strong></h2><h3 id="步骤-1：排查占用端口"><a href="#步骤-1：排查占用端口" class="headerlink" title="步骤 1：排查占用端口"></a><strong>步骤 1：排查占用端口</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i:3306</span><br><span class="line">ps -fp &lt;PID&gt;（在这之前可以先试试杀死占用3306端口的进程）</span><br></pre></td></tr></table></figure><ul><li>找到 mysqld 进程和父进程（守护进程）</li><li>确认路径，例如 <code>/usr/local/mysql/bin/mysqld</code></li></ul><hr><h3 id="步骤-2：停止所有虚拟机自带-MySQL-进程"><a href="#步骤-2：停止所有虚拟机自带-MySQL-进程" class="headerlink" title="步骤 2：停止所有虚拟机自带 MySQL 进程"></a><strong>步骤 2：停止所有虚拟机自带 MySQL 进程</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pkill -f mysqld_safe</span><br><span class="line"><span class="built_in">sudo</span> pkill -f /usr/local/mysql/bin/mysqld</span><br></pre></td></tr></table></figure><ul><li>确认端口已释放：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lsof -i:3306</span><br></pre></td></tr></table></figure><ul><li>输出为空表示干净</li></ul><hr><h3 id="步骤-3：禁止虚拟机自带旧-MySQL-开机启动"><a href="#步骤-3：禁止虚拟机自带旧-MySQL-开机启动" class="headerlink" title="步骤 3：禁止虚拟机自带旧 MySQL 开机启动"></a><strong>步骤 3：禁止虚拟机自带旧 MySQL 开机启动</strong></h3><ol><li>禁用 init 脚本：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> chkconfig mysql off</span><br></pre></td></tr></table></figure><ol><li>检查 rc.local 或 cron：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /etc/rc.local</span><br><span class="line">crontab -l</span><br><span class="line"><span class="built_in">sudo</span> crontab -l</span><br></pre></td></tr></table></figure><ul><li>注释掉任何启动 MySQL 的命令</li><li>cron 任务如有也需删除</li></ul><hr><h3 id="步骤-4：设置-Docker-容器开机自启"><a href="#步骤-4：设置-Docker-容器开机自启" class="headerlink" title="步骤 4：设置 Docker 容器开机自启"></a><strong>步骤 4：设置 Docker 容器开机自启</strong></h3><ol><li>对已有容器设置自启：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --restart unless-stopped mysql</span><br></pre></td></tr></table></figure><ol><li>启动容器：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start mysql</span><br></pre></td></tr></table></figure><ul><li>这样 mysql容器 会占用 3306，并且容器会随系统重启自动启动</li></ul><hr><h3 id="步骤-5：确保-Docker-服务开机启动"><a href="#步骤-5：确保-Docker-服务开机启动" class="headerlink" title="步骤 5：确保 Docker 服务开机启动"></a><strong>步骤 5：确保 Docker 服务开机启动</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure><ul><li>Docker 服务必须开机启动，容器自启才有效</li></ul><hr><h3 id="步骤-6：验证"><a href="#步骤-6：验证" class="headerlink" title="步骤 6：验证"></a><strong>步骤 6：验证</strong></h3><ol><li>查看容器状态：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul><li>确认容器状态是 <code>Up</code></li></ul><ol><li>重启虚拟机：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure><ol><li>再次查看容器：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul><li>如果容器 <code>Up</code> → 开机自启成功</li></ul><hr><h2 id="关键总结"><a href="#关键总结" class="headerlink" title="关键总结"></a><strong>关键总结</strong></h2><ol><li>手动安装 MySQL 通过 <code>mysqld_safe</code> 守护进程不断重启 → 单 kill 无效</li><li><code>/etc/init.d/mysql</code> 脚本可能开机启动旧 MySQL → <code>chkconfig mysql off</code> 禁用</li><li>彻底释放端口后，再启动 Docker MySQL</li><li>Docker 容器使用 <code>--restart unless-stopped</code> + Docker 服务开机自启 → 容器随系统重启自动启动</li></ol><hr>]]></content>
    
    
    <summary type="html">虚拟机中的 MySQL 3306端口被占用、mysql Docker 容器无法自启的解决办法。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Stream流</title>
    <link href="https://llwx2324.github.io/blog/2025/10/19/Stream%E6%B5%81/"/>
    <id>https://llwx2324.github.io/blog/2025/10/19/Stream%E6%B5%81/</id>
    <published>2025-10-19T02:00:00.000Z</published>
    <updated>2025-10-23T08:02:23.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🧩-一、Stream-是什么？"><a href="#🧩-一、Stream-是什么？" class="headerlink" title="🧩 一、Stream 是什么？"></a>🧩 一、Stream 是什么？</h2><blockquote><p><strong>Stream（流）</strong> 是对集合（或数组）中元素的一种”高级遍历与处理方式”。</p></blockquote><p>它不是集合本身，而是一个用来描述”数据流动和操作”的抽象层。</p><p> 过滤（filter）→ 转换（map）→ 收集结果（collect）<br> 这一条链式调用就是典型的 <strong>流式编程（Stream API）</strong>。</p><hr><h2 id="🧭-二、Stream-的核心设计理念"><a href="#🧭-二、Stream-的核心设计理念" class="headerlink" title="🧭 二、Stream 的核心设计理念"></a>🧭 二、Stream 的核心设计理念</h2><p>Stream 的使用分为 <strong>三步走</strong>：</p><table><thead><tr><th>阶段</th><th>说明</th><th>关键方法</th></tr></thead><tbody><tr><td>1️⃣ 创建流</td><td>从集合、数组等创建流</td><td><code>stream()</code>、<code>of()</code></td></tr><tr><td>2️⃣ 中间操作</td><td>对流中的元素进行处理（<strong>不会立即执行</strong>）</td><td><code>filter()</code>、<code>map()</code>、<code>sorted()</code>、<code>distinct()</code></td></tr><tr><td>3️⃣ 终止操作</td><td>执行最终计算（<strong>触发整个流的执行</strong>）</td><td><code>collect()</code>、<code>count()</code>、<code>forEach()</code></td></tr></tbody></table><p>⚠️ <strong>中间操作是惰性的</strong>：<br> 只有执行终止操作时，流才会真正遍历数据。</p><hr><h2 id="🧮-三、Stream-常用操作系统整理"><a href="#🧮-三、Stream-常用操作系统整理" class="headerlink" title="🧮 三、Stream 常用操作系统整理"></a>🧮 三、Stream 常用操作系统整理</h2><h3 id="（1）创建流"><a href="#（1）创建流" class="headerlink" title="（1）创建流"></a>（1）创建流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从集合创建</span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组创建</span></span><br><span class="line">Stream&lt;Integer&gt; s2 = Arrays.stream(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法创建</span></span><br><span class="line">Stream&lt;Double&gt; s3 = Stream.of(<span class="number">3.14</span>, <span class="number">2.71</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限流（需限制）</span></span><br><span class="line">Stream&lt;Integer&gt; s4 = Stream.iterate(<span class="number">1</span>, n -&gt; n + <span class="number">1</span>).limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="（2）中间操作（不会立刻执行）"><a href="#（2）中间操作（不会立刻执行）" class="headerlink" title="（2）中间操作（不会立刻执行）"></a>（2）中间操作（不会立刻执行）</h3><table><thead><tr><th>方法</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>filter(Predicate)</code></td><td>过滤元素</td><td><code>.filter(x -&gt; x &gt; 0)</code></td></tr><tr><td><code>map(Function)</code></td><td>元素映射（转换）</td><td><code>.map(String::length)</code></td></tr><tr><td><code>flatMap(Function)</code></td><td>扁平化多个流</td><td><code>.flatMap(List::stream)</code></td></tr><tr><td><code>distinct()</code></td><td>去重</td><td><code>.distinct()</code></td></tr><tr><td><code>sorted()</code></td><td>排序</td><td><code>.sorted(Comparator.naturalOrder())</code></td></tr><tr><td><code>peek(Consumer)</code></td><td>调试查看</td><td><code>.peek(System.out::println)</code></td></tr><tr><td><code>limit(n)</code></td><td>截取前 n 个</td><td><code>.limit(10)</code></td></tr><tr><td><code>skip(n)</code></td><td>跳过前 n 个</td><td><code>.skip(5)</code></td></tr></tbody></table><hr><h3 id="（3）终止操作（触发执行）"><a href="#（3）终止操作（触发执行）" class="headerlink" title="（3）终止操作（触发执行）"></a>（3）终止操作（触发执行）</h3><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><code>collect()</code></td><td>收集结果（通常转回集合）</td></tr><tr><td><code>count()</code></td><td>统计数量</td></tr><tr><td><code>forEach()</code></td><td>遍历输出</td></tr><tr><td><code>findFirst()</code> &#x2F; <code>findAny()</code></td><td>查找元素</td></tr><tr><td><code>allMatch()</code> &#x2F; <code>anyMatch()</code> &#x2F; <code>noneMatch()</code></td><td>匹配判断</td></tr><tr><td><code>reduce()</code></td><td>归约求和、合并操作</td></tr></tbody></table><hr><h2 id="🚀-四、Stream-的高级用法"><a href="#🚀-四、Stream-的高级用法" class="headerlink" title="🚀 四、Stream 的高级用法"></a>🚀 四、Stream 的高级用法</h2><h3 id="（1）map-vs-flatMap"><a href="#（1）map-vs-flatMap" class="headerlink" title="（1）map vs flatMap"></a>（1）<code>map</code> vs <code>flatMap</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map: 一对一</span></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a,b&quot;</span>, <span class="string">&quot;c,d&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)) <span class="comment">// Stream&lt;String[]&gt;</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap: 一对多，打平</span></span><br><span class="line">list.stream()</span><br><span class="line">    .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">&quot;,&quot;</span>))) <span class="comment">// Stream&lt;String&gt;</span></span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span></span><br></pre></td></tr></table></figure><hr><h3 id="（2）并行流（parallelStream）"><a href="#（2）并行流（parallelStream）" class="headerlink" title="（2）并行流（parallelStream）"></a>（2）并行流（parallelStream）</h3><p>利用多核 CPU 提高性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>).boxed().toList();</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> nums.parallelStream()</span><br><span class="line">               .mapToLong(Long::valueOf)</span><br><span class="line">               .sum();</span><br></pre></td></tr></table></figure><p>⚠️ 并行流适合<strong>无共享资源、计算量大</strong>的场景，否则反而更慢。</p><hr><h2 id="📦-五、collect-的常见用法"><a href="#📦-五、collect-的常见用法" class="headerlink" title="📦 五、collect 的常见用法"></a>📦 五、collect 的常见用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = users.stream()</span><br><span class="line">    .map(User::getName)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = list.stream().collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, String&gt; map = users.stream()</span><br><span class="line">    .collect(Collectors.toMap(User::getId, User::getName));</span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">avg</span> <span class="operator">=</span> list.stream()</span><br><span class="line">    .collect(Collectors.averagingInt(String::length));</span><br></pre></td></tr></table></figure><hr><h2 id="🧠-六、Stream-的特性总结"><a href="#🧠-六、Stream-的特性总结" class="headerlink" title="🧠 六、Stream 的特性总结"></a>🧠 六、Stream 的特性总结</h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>不存储数据</td><td>只对原集合的元素进行计算</td></tr><tr><td>不修改源数据</td><td>操作结果是新的流</td></tr><tr><td>惰性求值</td><td>中间操作不会立刻执行</td></tr><tr><td>可并行</td><td>可利用多核并行计算</td></tr></tbody></table><hr><h2 id="✅-七、完整实战例子"><a href="#✅-七、完整实战例子" class="headerlink" title="✅ 七、完整实战例子"></a>✅ 七、完整实战例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users = List.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">22</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Spike&quot;</span>, <span class="number">19</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; result = users.stream()</span><br><span class="line">    .filter(u -&gt; u.getAge() &gt;= <span class="number">20</span>)     <span class="comment">// 过滤</span></span><br><span class="line">    .sorted(Comparator.comparing(User::getAge)) <span class="comment">// 排序</span></span><br><span class="line">    .map(User::getName)                <span class="comment">// 提取名字</span></span><br><span class="line">    .collect(Collectors.toList());     <span class="comment">// 收集结果</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-八、与函数式接口的关系"><a href="#🧩-八、与函数式接口的关系" class="headerlink" title="🧩 八、与函数式接口的关系"></a>🧩 八、与函数式接口的关系</h2><p>Stream 中大量使用 Java 8 的函数式接口：</p><table><thead><tr><th>操作</th><th>对应接口</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>filter()</code></td><td><code>Predicate&lt;T&gt;</code></td><td>T → boolean</td><td></td></tr><tr><td><code>map()</code></td><td><code>Function&lt;T, R&gt;</code></td><td>T → R</td><td></td></tr><tr><td><code>forEach()</code></td><td><code>Consumer&lt;T&gt;</code></td><td>T → void</td><td></td></tr><tr><td><code>sorted()</code></td><td><code>Comparator&lt;T&gt;</code></td><td>(T, T) → int</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Stream流的简要介绍。</summary>
    
    
    
    
    <category term="Java" scheme="https://llwx2324.github.io/blog/tags/Java/"/>
    
    <category term="Stream" scheme="https://llwx2324.github.io/blog/tags/Stream/"/>
    
    <category term="函数式编程" scheme="https://llwx2324.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
